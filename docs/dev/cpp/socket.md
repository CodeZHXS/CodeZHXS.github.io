>   本文是我在学习 [《TCP/IP网络编程》【韩】尹圣雨 著](https://item.jd.com/11492130.html) 的过程中记下来的内容，旨在提醒自己在编写 `socket` 的时候需要注意的地方。本书浅显易懂，给了我很多启示，是少有的让我二刷的书籍，非常推荐。我将本文放到 `C/C++` 的目录下，是因为本书的代码用 `C` 编写，但是网络编程是和语言无关的，即使不从事 `C/C++` 的开发，我也建议阅读本书。

## 第 $9$ 章 套接字的多种可选项

`socket` 的可选项太多了，从实际问题出发进行设置是比较好的学习方式。

### 更改 I/O 缓冲大小

`socket` 的 I/O 缓冲影响的是程序在短时间内能够发送和接受的数据量，而不是 TCP 协议中的收发窗口的大小（即使是 UDP 套接字也能设置 I/O 缓冲大小）。这个设置可能会影响 TCP 协议的收发窗口大小。

即使手动设置这个值，操作系统也不一定会设置成完全一样的大小，仅仅是作为参考值（准确的说，操作系统设置的值会偏大）。

### 避免服务器 Time-Wait 状态引发的端口占用

TCP 四次握手的过程中，主动发起断开连接请求的一方，发出第四次挥手报文后进入 Time-Wait 状态，这个状态的时间设置为 2MSL，2MSL 之后才关闭自身的连接（回收用于双方通信的数据）。

假设现在 A（服务器）主动向 B（客户端）发起断开连接到请求，如果没有设置 Time-Wait 状态的话，这意味着 A 在发出第四次报文之后马上关闭了连接，如果第四次报文丢失了，此时 B 会超时重传第三次挥手的报文，但是 A 已经关闭了连接，所以不会管 B 的重传报文，也就无法发出第四次挥手的报文，只有 A 关闭了连接，而 B 只能在达到一定的重传次数或者过了一定时间才会关闭，造成了资源浪费。

实际的影响：考虑一种场景，B 向 A 发送的第三次挥手的重传报文总能按时到达，而 A 重传的 第四次挥手的报文一直丢失，这会导致 A 不断的重启 Time-Wait 计时器，也就是 A 无法关闭连接。在 Time-Wait 期间，套接字绑定的端口不能复用，必须等待连接彻底关闭之后才可以使用。

常常发生于服务器程序崩溃，此时服务器向所有的客户端断开连接，同一个端口处在 Time-Wait 状态无法被 `bind()` 函数绑定，为了避免这种情况，可以设置 `SO_REUSEADDR` 允许强制绑定。

### Nagle 算法

在 TCP 套接字中，`Nagle` 算法会尽可能减少网络中数据包的数量，将多个数据包进行合并。

应用场景1：发小数据，此时包头在总数据包的比例中较大，要开启 Nagle 算法，这样可以减少带宽消耗。此时发送缓冲的数据会停等一段时间，目的是尽可能与后续到来的数据进行合并之后发出，减少数据包的数量。这种算法启用连续 ACK 确认机制，缺点是消息有一定的时延。

应用场景2：传送文件，此时包头在总数据包的比例中较小，要关闭 Nagle 算法，因为每个数据包都会尽可能达到 TCP 报文的上限，在达到输入缓冲之后就发出。此时启用单个 ACK 确认机制，而且由于没有等待的过程，所以消息的时延较小。

---

## 第 $10$ 章 多进程服务端

### fork机制与套接字引用

`fork` 会从父进程复制出一个子进程，子进程拥有父进程的所用变量（包括全局变量，以及套接字的引用）。

复制过来的套接字会多一层引用，父进程和子进程引用同一个套接字，仅当两者都关闭这个套接字的时候才算关闭。

### 僵尸进程与销毁进程

僵尸进程：子进程的返回值没有被父进程捕获，这个进程就成为僵尸进程。僵尸进程的资源不会释放掉，所以父进程要及时处理。

父进程销毁的一个 **Trick**：父进程被销毁不会导致子进程被销毁。

### 多线程应用

对于服务端：多线程使得服务器能同时服务多个客户端。通常将服务器端的主进程作为连接管理的部分，而将具体服务客户端作为子进程。

对于客户端：多线程分割 IO，全双工通信。

---

## 第 $11$ 章 进程间通信

### 使用管道通信

`fork()` 得到的子进程会复制父进程的所有资源，变量相互独立。因此想让进程间共享数据，就必须共享操作系统层面的资源。管道和套接字一样，是操作系统的资源。

要想让 $2$ 个进程之间实现全双工通信，最好的做法是创建 $2$ 个管道。虽然 $1$ 个管道在理论上也可以做到，但较为繁琐。

## 第 $12$ 章 I/O 复用

多进程服务端的明显弊端：新建进程是很耗费资源的，而且一个进程对应一个客户端也有着明显的浪费，在大多数时候子进程要停等客户端的消息。

本章介绍的 `select` 模型可以解决这个问题，仍然使用一个进程处理所有的客户端，在 `select` 函数中监听特定的套接字的变化，可以监听可读、可写以及异常的发生，只对必要的套接字变化作出响应。

`fd_set` 表示想要监听的套接字的集合，在 `Unix` 中，`fd` 具有明显的连续增长的特点，因此 `fd_set` 内部的实现是 `bitset`。而在 `Windows` 中，套接字句柄之间没有明显的关系，所以 `fd_set` 内部的实现是动态数组。
