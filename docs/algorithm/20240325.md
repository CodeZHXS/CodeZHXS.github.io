## [I - 双向排序](https://www.lanqiao.cn/problems/1458/learning/?page=1&first_category_id=1&contain_answer=true&name=双向排序)

### 题目描述

给你一个序列 $a = (1, 2, \cdots, n)$，你需要执行 $m$ 种操作，操作有两种类型：

-   `0 x`：表示将序列的 $a_1, a_2, \cdots, a_x$ 降序排列。
-   `1 x`：表示将序列的 $a_{x+1}, a_{x+2}, \cdots, a_n$ 升序排列。

在 $m$​ 次操作全部执行完之后，输出这个序列。

---

### 数据范围

-   对于 $60\%$ 的数据， $1 \le n, m \le 5000$

-   对于所有的数据，$1 \le n, m \le 10^5$​

---

### $60\%$ pts 做法

>    对于 $60\%$ 的数据， $1 \le n, m < 5000$

对于每次操作，暴力的使用 `sort()` 排序。

单次操作的复杂度 $O(nlogn)$，一共 $m$ 次操作，总的时间复杂度为 $O(mnlogn)$，可以通过 $60\%$​ 的数据。

---

### $100\%$​ pts 做法

>   对于所有的数据，$1 \le n, m < 10^5$

我们需要将单次操作的时间压缩到 $logn$ 以内。

为此，我们需要挖掘一些性质：

-   **性质1**：任意时刻，整个序列要么是先减后增，要么是单调递增，要么是单调递减的。

先来看一个例子，假设初始的序列为：

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $a_i$ | $1$  | $2$  | $3$  | $4$  | $5$  | $6$  | $7$  |

某次操作将前缀 $[1, 3]$ 降序排列，序列变成：

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $a_i$ | $3$  | $2$  | $1$  | $4$  | $5$  | $6$  | $7$  |

**定义**：最后一个降序元素的下标为 $mid$，在上面的例子中，$mid=3$

$mid$ 是一条分界线，表示 $[1, mid]$ 这个区间是降序，$[mid+1, n]$ 这个区间就是升序。

如果整个序列是升序，则 $mid = 0$，如果整个序列是降序，则 $mid = n$。

接下来的几种可能的操作类型：

1.   假设 $mid = 3$，现在有一个操作，将区间 $[1, 2]$​ 降序，由于区间 $[1, 3]$​ 已经是降序，所以这个操作是不用做的。

     >   归纳：如果 $x \le mid$，则将 $[1, x]$ 降序没有意义。

2.   假设 $mid = 3$， 现在有一个操作，将区间 $[1, 4]$ 降序，由于 $4 > 3$，所以这个操作是有效的，操作执行后，$mid = 4$

     >   归纳：如果 $x > mid$，则将 $[1, x]$ 降序后，$mid$ 的值变成 $x$​。

3.   假设 $mid = 3$， 现在有一个操作，将区间 $[6, 7]$ 升序，由于区间 $[4, 7]$ 已经是降序，所以这个操作是不用做的。

     >   归纳：如果 $x \ge mid+1$，则将 $[x, n]$ 升序没有意义。

4.   假设 $mid = 3$，现在有一个操作，将区间 $[2, 7]$ 降序，由于 $2 < 4$，所以这个操作是有效的，操作执行后，$mid = 1$

     >   归纳：如果 $x < mid + 1$，则将 $[x, n]$ 升序后，$mid$ 的值变成 $x-1$。

此时序列变成：

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $a_i$ | $4$  | $1$  | $2$  | $3$  | $5$  | $6$  | $7$  |

-   **性质2**：下标越靠近 $mid$ 的数字值越小。

    证明：根据 $mid$ 的定义，区间 $[1, mid]$ 是降序，$[mid+1, n]$ 是升序，显然得证。

---

考虑给每个数字加上分区标签

$b_k = 0$ 表示数字 $k$ 当前在 $[1, mid]$ 的降序区间中。

$b_k = 1$ 表示数字 $k$ 当前在 $[mid+1, n]$ 的升序区间中。

一个 $b$ 数组可以对应一个序列的，例如，当前的 $b$ 数组为：

|  $k$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $b_k$ | $1$  | $1$  | $1$  | $0$  | $1$  | $1$  | $1$  |

对应的序列就是 $(4, 1, 2, 3, 5, 6, 7)$​，从后往前读 $0$，从前往后读 $1$

**只要维护 $b$ 数组，相当于维护整个序列。**

**考虑操作对 $b$ 数组的影响**

假设现在 $[1, mid]$ 是降序，$[mid+1, n]$ 是升序。

则 $b$ 数组中有 $mid$ 个 $0$，$n-mid$ 个 $1$。

1.   对于将 $[1, x]$ 降序，如果 $x \le mid$​，则没有意义，跳过。

2.   对于将 $[1, x]$ 降序，如果 $x > mid$，操作后 $mid$ 的值变成 $x$。

     这意味着操作后 $b$ 数组有 $x$ 个 $0$，而现在只有 $mid$ 个 $0$。

     所以还需要将 $x-mid$ 个 $1$ 改成 $0$，而这些数字是属于 $[mid+1, n]$​ 的升序区间的。

     又因为越靠近 $mid$ 的数字越小，所以只需要将最小的 $x-mid$ 个 $b_k = 0$ 改成 $b_k = 1$​​ 即可。


3.   对于将 $[x, n]$ 升序，如果 $x \ge mid+1$，则没有意义，跳过。

4.   对于将 $[x, n]$ 升序，如果 $x < mid + 1$，操作后 $mid$ 的值变成 $x - 1$。

     这意味着操作后 $b$ 数组有 $n-x+1$ 个 $1$，而现在只有 $n-mid$ 个 $1$。

     所以还需要将 $mid+1-x$ 个 $1$ 改成 $0$，而这些数字是属于 $[1, mid]$​ 的将序区间的。

     又因为越靠近 $mid$ 的数字越小，所以只需要将最小的 $mid+1-x$ 个 $b_k = 0$ 改成 $b_k = 1$ 即可。

**怎么快速修改？**

用线段树维护 $b$ 数组的区间和，在修改时计算出左右子树有多少个 $0$，优先进入左子树进行修改（因为左子树的值更小）。

??? Success "参考代码"

    === "C++"
    
        ```c++
        #include <iostream>
        #include <cstdio>
        #include <vector>
    
        using namespace std;
    
        const int maxn = 1E5 + 10;
        struct Node 
        {
            int sum, lazy;
        }t[maxn*4];
    
        void build(int p, int beg, int end)
        {
            t[p].lazy = -1;
            if(beg == end)
            {
                t[p].sum = 1;
                return;
            }
            int mid = (beg + end) / 2;
            int lch = p * 2, rch = p * 2 + 1;
            build(lch, beg, mid);
            build(rch, mid+1, end);
            t[p].sum = t[lch].sum + t[rch].sum;
        }
    
        void pushdown(int p, int beg, int end)
        {
            if(t[p].lazy == -1)
                return;
            int mid = (beg + end) / 2;
            int lch = p * 2, rch = p * 2 + 1;
            t[lch].sum = (mid-beg+1) * t[p].lazy;
            t[rch].sum = (end-mid) * t[p].lazy;
            t[lch].lazy = t[rch].lazy = t[p].lazy;
            t[p].lazy = -1;
        }
    
        // 将[beg, end]区间的前k个0改成1
        void zero_to_one(int p, int beg, int end, int k)
        {
            int cnt = end - beg + 1 - t[p].sum; // 计算[beg, end]有多少个0
            if(cnt <= k) // 如果本身不足k个就直接批量修改
            {
                t[p].sum = end - beg + 1; // 将这个区间全部改成1
                t[p].lazy = 1; // 打上懒标记
                return;
            }
            // 如果0的数量大于k个
            pushdown(p, beg, end);
            int mid = (beg + end) / 2;
            int lch = p * 2, rch = p * 2 + 1;
            int lcnt = mid - beg + 1 - t[lch].sum; // 计算左孩子还有多少个0
            if(lcnt < k) // 如果左孩子不足k个0
            {
                zero_to_one(lch, beg, mid, lcnt); // 左孩子全改成0
                zero_to_one(rch, mid+1, end, k-lcnt);
            }
            else 
                zero_to_one(lch, beg, mid, k); // 否则，只需要在左孩子上改k个
            t[p].sum = t[lch].sum + t[rch].sum;
        }
    
        // 将[beg, end]区间的前k个1改成0
        void one_to_zero(int p, int beg, int end, int k)
        {
            int cnt = t[p].sum; // 计算[beg, end]有多少个1
            if(cnt <= k) // 如果本身不足k个就直接批量修改
            {
                t[p].sum = 0; // 将这个区间全部改成0
                t[p].lazy = 0; // 打上懒标记
                return;
            }
            // 如果1的数量大于k个
            pushdown(p, beg, end);
            int mid = (beg + end) / 2;
            int lch = p * 2, rch = p * 2 + 1;
            int lcnt = t[lch].sum; // 计算左孩子还有多少个1
            if(lcnt < k) // 如果左孩子不足k个1
            {
                one_to_zero(lch, beg, mid, lcnt); // 左孩子全改成0
                one_to_zero(rch, mid+1, end, k-lcnt);
            }
            else 
                one_to_zero(lch, beg, mid, k); // 否则，只需要在左孩子上改k个
            t[p].sum = t[lch].sum + t[rch].sum;
        }
    
        int ask(int p, int beg, int end, int pos)
        {
            if(beg == end)
                return t[p].sum;
            pushdown(p, beg, end);
            int mid = (beg + end) / 2;
            int lch = p * 2, rch = p * 2 + 1;
            return pos <= mid ? ask(lch, beg, mid, pos) : ask(rch, mid+1, end, pos);
        }
    
        int main()
        {
            int n, m;
            cin >> n >> m;
            build(1, 1, n);
            int mid = 0, op, x;
            while(m--)
            {
                scanf("%d %d", &op, &x);
                if(op == 0)
                {
                    if(x <= mid)
                        continue;
                    one_to_zero(1, 1, n, x - mid);
                    mid = x;
                }
                else
                {
                    if(x >= mid+1)
                        continue;
                    zero_to_one(1, 1, n, mid + 1 - x);
                    mid = x-1;
                }
            }
            vector<int> zero, one;
            for(int i = 1; i <= n; i++)
                ask(1, 1, n, i) ? one.push_back(i) : zero.push_back(i);
            for(int i = zero.size()-1; i >= 0; i--)
                printf("%d ", zero[i]);
            for(auto x : one)
                printf("%d ", x);
            return 0;
        }
        ```
    
    === "Java"
    
        ```java
        import java.util.ArrayList;
        import java.util.Scanner;
    
        class Node {
            public int sum, lazy;
        };
    
        public class Main {
    
            private static Node[] t;
    
            private static void build(int p, int beg, int end) {
                t[p] = new Node();
                t[p].lazy = -1;
                if (beg == end) {
                    t[p].sum = 1;
                    return;
                }
                int mid = (beg + end) / 2;
                int lch = p * 2, rch = p * 2 + 1;
                build(lch, beg, mid);
                build(rch, mid + 1, end);
                t[p].sum = t[lch].sum + t[rch].sum;
            }
    
            private static void pushdown(int p, int beg, int end) {
                if (t[p].lazy == -1)
                    return;
                int mid = (beg + end) / 2;
                int lch = p * 2, rch = p * 2 + 1;
                t[lch].sum = (mid - beg + 1) * t[p].lazy;
                t[rch].sum = (end - mid) * t[p].lazy;
                t[lch].lazy = t[rch].lazy = t[p].lazy;
                t[p].lazy = -1;
            }
    
            // 将[beg, end]区间的前k个0改成1
            private static void zero_to_one(int p, int beg, int end, int k) {
                int cnt = end - beg + 1 - t[p].sum; // 计算[beg, end]有多少个0
                if (cnt <= k) // 如果本身不足k个就直接批量修改
                {
                    t[p].sum = end - beg + 1; // 将这个区间全部改成1
                    t[p].lazy = 1; // 打上懒标记
                    return;
                }
                // 如果0的数量大于k个
                pushdown(p, beg, end);
                int mid = (beg + end) / 2;
                int lch = p * 2, rch = p * 2 + 1;
                int lcnt = mid - beg + 1 - t[lch].sum; // 计算左孩子还有多少个0
                if (lcnt < k) // 如果左孩子不足k个0
                {
                    zero_to_one(lch, beg, mid, lcnt); // 左孩子全改成0
                    zero_to_one(rch, mid + 1, end, k - lcnt);
                } else
                    zero_to_one(lch, beg, mid, k); // 否则，只需要在左孩子上改k个
                t[p].sum = t[lch].sum + t[rch].sum;
            }
    
            // 将[beg, end]区间的前k个1改成0
            private static void one_to_zero(int p, int beg, int end, int k) {
                int cnt = t[p].sum; // 计算[beg, end]有多少个1
                if (cnt <= k) // 如果本身不足k个就直接批量修改
                {
                    t[p].sum = 0; // 将这个区间全部改成0
                    t[p].lazy = 0; // 打上懒标记
                    return;
                }
                // 如果0的数量大于k个
                pushdown(p, beg, end);
                int mid = (beg + end) / 2;
                int lch = p * 2, rch = p * 2 + 1;
                int lcnt = t[lch].sum; // 计算左孩子还有多少个1
                if (lcnt < k) // 如果左孩子不足k个1
                {
                    one_to_zero(lch, beg, mid, lcnt); // 左孩子全改成0
                    one_to_zero(rch, mid + 1, end, k - lcnt);
                } else
                    one_to_zero(lch, beg, mid, k); // 否则，只需要在左孩子上改k个
                t[p].sum = t[lch].sum + t[rch].sum;
            }
    
            private static int ask(int p, int beg, int end, int pos) {
                if (beg == end)
                    return t[p].sum;
                pushdown(p, beg, end);
                int mid = (beg + end) / 2;
                int lch = p * 2, rch = p * 2 + 1;
                return pos <= mid ? ask(lch, beg, mid, pos) : ask(rch, mid + 1, end, pos);
            }
    
            public static void main(String[] args) {
                Scanner in = new Scanner(System.in);
                int n = in.nextInt();
                int m = in.nextInt();
                t = new Node[n * 4];
                build(1, 1, n);
                int mid = 0, op, x;
                while (m-- > 0) {
                    op = in.nextInt();
                    x = in.nextInt();
                    if (op == 0) {
                        if (x <= mid)
                            continue;
                        one_to_zero(1, 1, n, x - mid);
                        mid = x;
                    } else {
                        if (x >= mid + 1)
                            continue;
                        zero_to_one(1, 1, n, mid - x + 1);
                        mid = x - 1;
                    }
                }
                ArrayList<Integer> zero = new ArrayList<>();
                ArrayList<Integer> one = new ArrayList<>();
                for (int i = 1; i <= n; i++)
                    if (ask(1, 1, n, i) == 1)
                        one.add(i);
                    else
                        zero.add(i);
                for (int i = zero.size() - 1; i >= 0; i--)
                    System.out.printf("%d ", zero.get(i));
                for (int i = 0; i < one.size(); i++)
                    System.out.printf("%d ", one.get(i));
                in.close();
            }
        }
        ```
        
     === "Python"
    
        ```python
    
        ```
