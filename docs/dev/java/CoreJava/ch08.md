## 定义简单泛型类

下面代码实现了 `C++` 中的模板类 `pair`：

```java
class Pair<T, U> {
    private T first;
    private U second;

    public Pair() {first = null; second = null;}
    public Pair(T f, U s) {first = f; second = s;}

    public T getFirst() {return first;}
    public U getSecond() {return second;}

    public void setFirst(T x) {first = x;}
    public void setSecond(U x) {second = x;}
}
```

## 泛型方法

下面方法是一个泛型方法，返回任意类型数组的中间元素：

```java
public static <T> T getMiddle(T[] a)
{return a[a.length / 2];}
```

在大多数情况下，调用泛型方法时可以省略具体的类型参数，编译会自动推倒并匹配。

## 类型变量的限定

在定义泛型的位置可以可以对泛型进行限定，例如可以声明泛型必须是实现某个接口。

下面的例子是一个求出数组中最小和最大元素的泛型方法，其中限定了泛型只能是实现了 `Comparable` 接口的类：

```java
class ArrayAlg {
    public static <T extends Comparable> Pair<T, T> minmax(T[] a) {
        if (a == null || a.length == 0)
            return null;
        T m = a[0], M = a[0];
        for (int i = 1; i < a.length; i++) {
            if (a[i].compareTo(m) < 0)
                m = a[i];
            else if (a[i].compareTo(M) > 0)
                M = a[i];
        }
        return new Pair<>(m, M);
    }
}
```

## Java 泛型和 C++ 模板类的区别

-   `Java` 泛型可以对泛型的类型加以限制，而 `C++` 不行。
-   `Java` 虚拟机没有泛型类型对象，类型变量会被“擦除”，并替换为限定类型（如果是无限定类型的变量则替换为 `Object`）。而 `C++` 会为每个模板的实例化产生不同的类型，导致“模板代码膨胀”。
